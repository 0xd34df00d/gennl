\documentclass[12pt,a4paper]{amsart}
\usepackage{a4wide}
\usepackage[utf8]{inputenc}
\usepackage[T2A]{fontenc}
\usepackage{graphics,graphicx,epsfig}
\usepackage{amssymb,amsfonts,amsthm,amsmath,mathtext,cite,enumerate,float}
\usepackage[english,russian]{babel}
\usepackage[all]{xy}
\usepackage{morefloats}
\usepackage{pgf}
\usepackage[outputdir={docgraphs/}]{dot2texi}
\usepackage{tikz}
\usepackage{scalefnt}
\usetikzlibrary{shapes,arrows}
\usetikzlibrary{decorations.pathmorphing}

% Comment the following block when compiling this .tex with a saner compiler than texlive.
\makeatletter
\def\@settitle{\begin{center}%
    \baselineskip14\p@\relax
    \bfseries
    \@title
  \end{center}%
}
\makeatother

\begin{document}
% Comment the following block when compiling this .tex with a saner compiler than texlive.
\pagestyle{plain}

\title{Алгоритмы порождения существенно нелинейных моделей}
\author{Г.\,И.~Рудой}
\address{Московский физико-технический институт, ФУПМ, каф. <<Интеллектуальные системы>>}
\thanks{Научный руководитель В.\,В.~Стрижов}

\begin{abstract}
  В работе исследуются алгоритмы порождения и отбора существенно нелинейных моделей (символьная регрессия). Полученные модели применяются для восстановления регрессионной зависимости переменной от данных числовых рядов. Описывается представление моделей в виде матриц смежности. В вычислительном эксперименте приводятся результаты для задачи моделирования волатильности опционов.
\end{abstract}

\maketitle

\section{Система обозначений}

% TODO rewrite with the glossaries package ( http://en.wikibooks.org/wiki/LaTeX/Glossary )
\begin{itemize}
  \item $ \mathcal{A} $ --- множество индексов информативных признаков.
  \item $ G $ --- множество элементарных функций, используемых для составления суперпозиций.
	\footnote{Имеет смысл четко определить, откуда и куда действуют функции из $G$: $G = { g : R^n \to R^n \mid \forall n }$
		или же $ G = { g : R \to R \lor R \times R \to R} $. В принципе, второго случая должно за глаза хватить ---
		используемые функции либо одноместные (например, $\log$, $\tan$, $\neg$), либо двухместные (например, $+$, $\times$, $\land$).}
  \item $ \overline{G} $ --- пополненное множество элементарных функций:
	$ \overline{G} = G\ \cup\ G_X = \{ \overline{g}_i : X \to R \mid i = 1, \dots, N\} $,
	где $\overline{g}_i$ --- функция, возвращающая $i$-ый признак из множества признаков $X$.
  \item $ \mathcal{I} $ --- множество индексов всех признаков.
  \item $ N $ --- мощность множества числовых признаков (число признаков).
  \item $ \overline{N} $ --- мощность пополненного множества числовых признаков ($\overline{N} = |G| + N$).
  \item $ x_i $ --- признак.
  \item $ X $ --- множество числовых признаков: $ X = \cup_{i = 1}^N {x_i}$.
\end{itemize}

\section{Описание регрессионных моделей при помощи матриц смежности}

Условимся руководствоваться следующим очевидным правилом при составлении суперпозиций: в листьях соответствующего
дерева выражений содержатся функции из $G_X$ и только они.

Сопоставим суперпозиции матрицу смежности, ее описывающую, и укажем способ ее построения.

Пусть дана произвольная суперпозиция функций из $G$ в инфиксной записи. Требуется построить соответствующую данной
суперпозиции матрицу. Таким образом мы заодно и опишем, что представляет из себя матрица, характеризующая суперпозицию,
и укажем некоторые ее свойства.

Первым шагом является построение дерева грамматического разбора выражения в инфиксной записи, эта тема хорошо изучена
и разобрана, например, в \cite{Aho86}, поэтому положим, что мы уже имеем дерево выражения. Заметим, что дерево
выражения является ориентированным графом. Пронумеруем его вершины, запустив по графу поиск в глубину. Присвоим каждой
вершине номер, соответствующий ее порядку при таком обходе в глубину, и условимся считать первой вершину, из которой
был начат обход.

Если в суперпозиции участвует $n$ функций, то, соответственно, получим индексы $1, \dots, n$. Построим матрицу
$A = \| a_{ij} \|$ размера $n \times n$ и запишем в элемент $a_{ij}$ единицу, если в графе есть ребро, соединяющее
$i$-ую и $j$-ую вершины, иначе --- ноль.

Так как в $G$ могут существовать коммутативные сами с собой операции, то порядок следования узлов графа, вообще говоря,
недетерминирован, поэтому вместе с матрицей необходимо хранить вектор размерности $n$, указывающий, какому индексу
соответствует какая функция.

Заметим следующие очевидные свойства:

\begin{itemize}
  \item На диагонали матрицы стоят нули (так как в графе по определению отсутствуют петли).
  \item Матрица верхнетреугольная (так как граф --- дерево, и по построению нумерации ребра есть только от элементов
	с меньшим номером к элементам с большим).
  \item В каждом столбце может быть только одна единица, исключая первый столбец, в котором ноль единиц.
  \item Сумма числа единиц в строке характеризует арность функции с соответствующим индексом и ее принадлежность к $G$
	либо $G_X$: унарная функция из $G$ имеет одну единицу, бинарная $G$ --- две, а имеющая только нули функция лежит в $G_X$.
\end{itemize}

\subsection{Пример}

Пусть дано выражение $ \sin (\ln x_1) + \frac{x_2^3}{2}$. Построим соответствующий граф и пронумеруем вершины:

\begin{tikzpicture}
\scalefont{2}
\tikzstyle{n} = [draw, inner sep=2pt, fill=red!20]
\begin{dot2tex}[dot,options=-tmath,scale=0.25]
  digraph G1 {
	node [shape="circle",style="n"];
	
	Plus [label="\bullet + \bullet \,\,\,(1)"];
	Sin [label="\sin \bullet \,\,\,(2)"];
	Ln [label="\ln \bullet \,\,\,(3)"];
	X1 [label="x_1 \,\,\,(4)"];
	Frac [label="\div \,\,\,(5)"];
	Pow [label="\bullet^{\bullet} \,\,\,(6)"];
	X2 [label="x_2 \,\,\,(7)"];
	N3 [label="3 \,\,\,(8)"];
	N2 [label="2 \,\,\,(9)"];

	Plus -> Sin;
	Sin -> Ln;
	Ln -> X1;

	Plus -> Frac;
	Frac -> Pow;
	Frac -> N2;

	Pow -> X2;
	Pow -> N3;
  }
\end{dot2tex}
\end{tikzpicture}

Тогда матрица смежности для этого графа будет выглядеть как:

$$
\bordermatrix{
~ 	 			  & 1 & 2 & 3 & 4 & 5 & 6 & 7 & 8 & 9 \cr
+			      & 0 & 1 & 0 & 0 & 1 & 0 & 0 & 0 & 0 \cr
\sin 			  & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 \cr
\ln				  & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 \cr
x_1				  & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 \cr
\div 			  & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 1 \cr
\bullet^{\bullet} & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 1 & 0 \cr
x_2				  & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 \cr
3				  & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 \cr
2				  & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0
}
$$

\subsection{Сложность модели}

Если считать сложностью модели число используемых признаков, то число нулевых строк в матрице смежности как раз и будет
характеризовать сложность модели.

\section{Описание регрессионных моделей при помощи матриц инцидентности}

Аналогично методу построения матриц смежности, представим данное выражение ориентированным графом и запустим поиск в
глубину, нумеруя по мере обхода вершины и ребра, и условимся считать вершину, из которой начат обход, первой. Очевидно,
что ребер на единицу меньше, чем функций, и что ребро перед $i$-ой вершиной имеет номер $i - 1$.

Построим матрицу размера $n \times (n - 1)$, где $n$ --- число функций, участвующих в суперпозиции, и для каждого столбца
за номером $i$ запишем единицы в клетки с номерами строк, соответствующими номерам функций, соединяемых этим ребром, а
все остальные клетки запишем нули.

Заметим, что матрица инцидентности сама по себе характеризует лишь структуру соответствующего выражения, и необходимо
хранить еще и вектор функций, ставящий в соответствие номеру строки конкретную функцию из выражения. Назовем такой вектор
связанным с матрицей вектором (или просто связанным вектором).

\begin{itemize}
  \item \label{prop:inc_mat_two_ones} В каждом столбце матрицы ровно две единицы.
  \item \label{prop:inc_mat_row_ones} Для первой (по порядку обхода) функции число единиц в соответствующей строке равно
	арности функции, для всех остальных функций это число равно арности функции, увеличенной на единицу.
  \item \label{prop:inc_mat_struct} $ a_{ij} = 1 \mid \forall j, i = j + 1 $ и $ a_{ij} = 0 \mid \forall j, \forall i > j + 1 $.
\end{itemize}

Таким образом, соблюдение и проверка вышеупомянутых свойств матрицы при дальнейших преобразованиях, в том числе,
гарантирует выполнение базовых ограничений, получаемых из соображений разумности, таких, как:

\begin{itemize}
  \item Соответствие реального числа аргументов в выражении арности функции (достаточно сопоставить количество единиц
	в соответствующей строке информации с функцией в связанном векторе).
  \item Отсутствие функций, вызывающих сами себя (для выполнения этого условия необходимо и достаточно выполнение
	первого и третьего свойств).
\end{itemize}

Отметим также следующие ограничения, которые также тривиально проверяются для матриц инцидентности:

\begin{itemize}
  \item Соответствие области значений дочерних функций области определения вызывающей функции.
  \item Условия на область определения результата.
  \item Соответствие типов аргументов.
\end{itemize}

\subsection{Структура матрицы и связь с поддеревьями}

Рассмотрим некоторое поддерево выражения. Пусть оно начинается с вершины за номером $b$, и последняя вершина по порядку
обхода имеет номер $e$.

Номера вершин поддерева содержатся в интервале $[b, e]$ и, более того, для каждого натурального числа из этого интервала
найдется вершина, имеющая соответствующий номер; это следует из порядка обхода графа. Из этого напрямую следует, что
подматрица, соответствующая данному поддереву, лежит в диапазоне между клетками $(b, b - 1)$ и $(e, e - 1)$.

\subsubsection{Выделение поддерева по номеру начальной вершины} Таким образом, с учетом указанных выше свойств, можно
сформулировать следующий алгоритм нахождения подматрицы, описывающей поддерево, начинающееся с вершины за номером $b$
(который, по факту, номер последней вершины $e$):

\begin{enumerate}
  \item $i := b$
  \item Находим $ c_{max} := \sup \{ j \mid a_{ij} = 1 \}$ (множество не пусто по свойству матрицы \ref{prop:inc_mat_struct}).
	Если $ c_{max} = i - 1 $, то завершаем алгоритм с $e := i$, иначе переходим к следующему шагу.
  \item Находим $ r_{max} := \sup \{ r \mid a_{rc_{max}} = 1 \}; i := r_{max} $ и переходим к предыдущему шагу.
\end{enumerate}

Алгоритм всегда завершается, так как на каждом шаге мы сдвигаемся вправо либо вниз, и матрица ограничена.

Заметим также, что последний шаг корректен, и $ r_{max} > i $.\footnote{Строго доказать, почему}

\subsection{Пример}

Пусть дано выражение $ \sin (\ln x_1) + \frac{x_2^3}{2}$. Построим соответствующий граф, пронумеруем вершины и ребра:

\begin{tikzpicture}
\tikzstyle{n} = [draw, inner sep=4pt, fill=red!20]
\scalefont{5}
\begin{dot2tex}[dot,options=-tmath,scale=0.25]
  digraph G1 {
	node [shape="circle",style="n"];
	
	Plus [label="\bullet + \bullet \,\,\,(1)"];
	Sin [label="\sin \bullet \,\,\,(2)"];
	Ln [label="\ln \bullet \,\,\,(3)"];
	X1 [label="x_1 \,\,\,(4)"];
	Frac [label="\div \,\,\,(5)"];
	Pow [label="\bullet^{\bullet} \,\,\,(6)"];
	X2 [label="x_2 \,\,\,(7)"];
	N3 [label="3 \,\,\,(8)"];
	N2 [label="2 \,\,\,(9)"];

	Plus -> Sin [label="(1)"];
	Sin -> Ln [label="(2)"];
	Ln -> X1 [label="(3)"];

	Plus -> Frac [label="(4)"];
	Frac -> Pow [label="(5)"];
	Frac -> N2 [label="(8)"];

	Pow -> X2 [label="(6)"];
	Pow -> N3 [label="(7)"];
  }
\end{dot2tex}
\end{tikzpicture}

Тогда матрица инцидентности для этого графа будет выглядеть как:

$$
\bordermatrix{
~ 	 			  & 1 & 2 & 3 & 4 & 5 & 6 & 7 & 8 \cr
+			      & 1 & 0 & 0 & 1 & 0 & 0 & 0 & 0 \cr
\sin 			  & 1 & 1 & 0 & 0 & 0 & 0 & 0 & 0 \cr
\ln				  & 0 & 1 & 1 & 0 & 0 & 0 & 0 & 0 \cr
x_1				  & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 \cr
\div 			  & 0 & 0 & 0 & 1 & 1 & 0 & 0 & 1 \cr
\bullet^{\bullet} & 0 & 0 & 0 & 0 & 1 & 1 & 1 & 0 \cr
x_2				  & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 \cr
3				  & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 \cr
2				  & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1
}
$$


\subsection{Применение генетических алгоритмов}

Выразим операции кроссовера и мутации через язык матриц инцидентности.

\subsubsection{Мутация}

Мутация, то есть, замена функции на другую, сводится к замене функции на соответствующей позиции в связанном векторе
на другую функцию. При этом необходимо обеспечить сохранение арности, то есть, заменять функцию только на функцию с
таким же числом аргументов. Необходимо также не испортить области значения: сохранить соответствие области значений
дочерних функций области определения новой функции, а области значений новой функции --- областям определения функций,
для которых новая функция является дочерней.

\subsubsection{Кроссовер}

Рассмотрим сначала одноточечный кроссовер, при котором поддерево выражения заменяется на соответствующее поддерево
другого выражения целиком, начиная с некоторой вершины и до листьев дерева.

Пусть номер вершины, начиная с которой произведется замена, в одном выражении --- $b_1$, а в другом $b_2$, при этом
соответствующим поддеревьям принадлежат вершины с номерами, не большими $e_1$ и $e_2$, и эти границы достигаются.
Тогда необходимо:

\begin{enumerate}
  \item Выделить в матрице первого выражения подматрицу, начиная с клетки $ (b_1, b_1 - 1) $ и до клетки
	$ (e_1, e_1 - 1) $ включительно.
  \item Выделить в матрице второго выражения подматрицу, начиная с клетки $ (b_2, b_2 - 1) $ и до клетки
	$ (e_2, e_2 - 1) $ включительно.
  \item Обменять выделенные подматрицы местами, при необходимости записывая в недостающие клетки нули (если новая
	подматрица больше выделенной) либо убирая ненужные столбцы и строки (если новая подматрица меньше).
  \item Обменять элементы в связанных векторах начиная с $ n_1 $ для первого вектора и с $ n_2 $ для второго
	соответственно.
\end{enumerate}

Однако, генетические алгоритмы работают напрямую с матрицами и не следят за сопутствующим графом (это было бы
неоправданной тратой ресурсов), поэтому необходимо заметить, что соответствующая процедура должна для сохранения
корректности и разумности выражения выбирать те подматрицы, для которых на строках, принадлежащих этой подматрице,
вне этой подматрицы стоят только нули, и аналогично для столбцов, принадлежащих этой подматрице, кроме самого левого,
который, возможно, имеет одну единицу над подматрицей.

Заметим, что, с учетом предыдущего замечания, по указанному ранее свойству локализации поддерева в матрице эти
операции корректны и приводят к корректным результирующим матрицам и, таким образом, при кроссовере необходимо
вручную проверять только соответствие областей определения.

Рассмотрим для примера, как в матричном представлении выражается получение выражения $ \sin x_1 + x_1 \cos x_2 $ из
выражений $ \sin x_1 + x_2 $ и $ x_1 + x_1 \cos x_2 $, то есть, в соответствующем графе для первого родительского
выражения поддерево, отвечающее подвыражению $ x_2 $, заменяется на поддерево $ x_1 \cos x_2 $.

Запишем матрицы инцидентности для первого и второго исходных выражений, соответственно, и отметим соответствующие
поддеревьям подматрицы:

$$
\begin{pmatrix}
  +			& \multicolumn{1}{|c}{1} & 0 & 1 \\
  \sin		& \multicolumn{1}{|c}{1} & 1 & 0 \\
  x_1		& \multicolumn{1}{|c}{0} & 1 & 0 \\ \cline{4-4}
  x_2		& \multicolumn{1}{|c}{0} & 0 &\multicolumn{1}{|c}{1}
\end{pmatrix}
\qquad
\begin{pmatrix}
  +			& \multicolumn{1}{|c}{1} &						1 & 0 & 0 & 0 \\
  x_1		& \multicolumn{1}{|c}{1} &						0 & 0 & 0 & 0 \\ \cline{3-6}
  \times	& \multicolumn{1}{|c}{0} & \multicolumn{1}{|c}{1} & 1 & 1 & 0 \\
  x_1		& \multicolumn{1}{|c}{0} & \multicolumn{1}{|c}{0} & 1 & 0 & 0 \\
  \cos		& \multicolumn{1}{|c}{0} & \multicolumn{1}{|c}{0} & 0 & 1 & 1 \\
  x_2		& \multicolumn{1}{|c}{0} & \multicolumn{1}{|c}{0} & 0 & 0 & 1
\end{pmatrix}
$$

Для результирующего выражения:

$$
\begin{pmatrix}
  +			& \multicolumn{1}{|c}{1} & 0 & \multicolumn{1}{c|}{1} & 0 & 0 & 0 \\
  \sin		& \multicolumn{1}{|c}{1} & 1 & \multicolumn{1}{c|}{0} & 0 & 0 & 0 \\
  x_1		& \multicolumn{1}{|c}{0} & 1 & \multicolumn{1}{c|}{0} & 0 & 0 & 0 \\ \cline{2-4} \cline{4-7}
  \times	& \multicolumn{1}{|c}{0} & 0 & \multicolumn{1}{|c}{1} & 1 & 1 & 0 \\
  x_1		& \multicolumn{1}{|c}{0} & 0 & \multicolumn{1}{|c}{0} & 1 & 0 & 0 \\
  \cos		& \multicolumn{1}{|c}{0} & 0 & \multicolumn{1}{|c}{0} & 0 & 1 & 1 \\
  x_2		& \multicolumn{1}{|c}{0} & 0 & \multicolumn{1}{|c}{0} & 0 & 0 & 1
\end{pmatrix}
$$

Двухточечный кроссовер можно выразить как последовательное применение двух одноточечных кроссоверов: первый обменивает
меньшие поддеревья, затем второй --- большие.

\section{Вычислительный эксперимент}

\section{Замечания}

\begin{itemize}
  \item При использовании только функций $R \to R$ и $R \times R \to R$ очень легко считать сложность модели по ее
	матрице, но, в то же время, описание даже банальной однослойной нейросети становится довольно громоздким.
  \item Если же, наоборот, разрешить функции из пространства произвольной размерности, то (по крайней мере, для моделей
	типа двухсловной нейросети) придется в $G$ иметь варианты операции суммирования, действующие из
	$R^n \mid \forall n \in \mathbb{N}$, что, по факту, делает $G$ по крайней мере счетным. Либо надо делать для
	операции суммирования исключение, а потребность в таком частном случае, скорее всего, означает о неправильно
	выбранных примитивах.
  \item Можно попробовать обойтись без введения пополненного множества, а вместо этого договориться записывать в
	соответствующий вектор не $\overline{g}_i$, а сразу $x_i$, но это по большей части вопрос обозначений.
\end{itemize}

\bibliographystyle{unsrt}
\extrasrussian
\bibliography{bibliography}

\end{document}
